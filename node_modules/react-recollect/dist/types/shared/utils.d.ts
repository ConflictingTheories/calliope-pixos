import { ArrWithSymbols, MapWithSymbols, ObjWithSymbols, SetWithSymbols, Target } from './types';
export declare const isObject: (item: any) => item is ObjWithSymbols;
export declare const isArray: (item: any) => item is ArrWithSymbols;
export declare const isMap: (item: any) => item is MapWithSymbols;
export declare const isSet: (item: any) => item is SetWithSymbols;
export declare const isTarget: (item: any) => item is Target;
export declare const isInternal: (prop: any) => boolean;
export declare const isFunction: (item: any) => boolean;
export declare const isArrayMutation: (target: Target, prop: any) => boolean;
export declare const clone: <T extends Target>(target: T) => T;
declare type GetValue = {
    (item: ObjWithSymbols, prop: PropertyKey): any;
    (item: ArrWithSymbols, prop: number): any;
    (item: MapWithSymbols, prop: any): any;
    (item: SetWithSymbols, prop: any): any;
};
/**
 * Get the value from an object. This is for end-user objects. E.g. not
 * accessing a symbol property on a Map object.
 */
export declare const getValue: GetValue;
declare type SetValue = {
    (item: ObjWithSymbols, prop: PropertyKey, value: any): void;
    (item: ArrWithSymbols, prop: number, value: any): void;
    (item: MapWithSymbols, prop: any, value: any): void;
    /** For consistency, we'll just pass value twice for sets */
    (item: SetWithSymbols, prop: any, value: any): void;
};
export declare const setValue: SetValue;
export declare const getSize: (item: Target) => number;
/**
 * Shallow replaces the contents of one object with the contents of another.
 * The top level object will remain the same, but all changed content will
 * be replaced with the new content.
 */
export declare const replaceObject: (mutableTarget: ObjWithSymbols, nextObject?: ObjWithSymbols | undefined) => void;
/**
 * Traverse a tree, calling a callback for each node with the item and the path.
 * This can either mutate each value, or return a new value to create a clone.
 * @example const clone = utils.updateDeep(original, utils.clone);
 * Only traverses the targets supported by Recollect.
 */
export declare const updateDeep: <T extends Target>(mutableTarget: T, updater: <U extends Target>(item: U, path: any[]) => void | U) => T;
/**
 * Does some work while the proxy is muted. Returns the result of the
 * callback as a convenience.
 * This prevents components from being subscribed to reads from the store,
 * it does not prevent updates being triggered.
 */
export declare const whileMuted: <T>(cb: () => T) => T;
/**
 * This is a convenience method that triggers a read on each item in the array.
 * When used during the render cycle of a collected component, it has the
 * side-effect of subscribing that component to each item in the array.
 */
export declare const useProps: (props: any[]) => void;
export {};
