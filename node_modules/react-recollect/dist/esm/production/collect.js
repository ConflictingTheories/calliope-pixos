import state$1 from './shared/state.js';
import { whileMuted } from './shared/utils.js';
import { debug as debug$1 } from './shared/debug.js';
import { createShallow } from './proxyManager.js';
import { removeListenersForComponent } from './updateManager.js';
import React$1 from 'react';
import hoistNonReactStatics$1 from 'hoist-non-react-statics';

// As we render down into a tree of collected components, we will start/stop
// recording
const componentStack = [];
const startRecordingGetsForComponent = (component) => {
    if (!state$1.isInBrowser)
        return;
    debug$1(() => {
        console.groupCollapsed(`RENDER: <${component._name}>`);
    });
    state$1.currentComponent = component;
    componentStack.push(state$1.currentComponent);
};
const stopRecordingGetsForComponent = () => {
    if (!state$1.isInBrowser)
        return;
    debug$1(() => {
        console.groupEnd();
    });
    componentStack.pop();
    state$1.currentComponent = componentStack[componentStack.length - 1] || null;
};
/**
 * This shallow clones the store to pass as state to the collected
 * component.
 */
const getStoreClone = () => whileMuted(() => {
    // We'll shallow clone the store so React knows it's new
    const shallowClone = Object.assign({}, state$1.store);
    // ... but redirect all reads to the real store
    state$1.nextVersionMap.set(shallowClone, state$1.store);
    return createShallow(shallowClone);
});
const collect = (ComponentToWrap) => {
    const componentName = ComponentToWrap.displayName || ComponentToWrap.name || 'NamelessComponent';
    class WrappedComponent extends React$1.PureComponent {
        constructor() {
            super(...arguments);
            this.state = {
                // This might be called by React when a parent component has updated with a new store,
                // we want this component (if it's a child) to have that next store as well.
                store: getStoreClone(),
            };
            // TODO (davidg) 2020-02-28: use private #isMounted, waiting on
            //  https://github.com/prettier/prettier/issues/7263
            this._isMounted = false;
            this._isMounting = true;
            // <React.StrictMode> will trigger multiple renders,
            // we must disregard these
            this._isRendering = false;
            this._name = componentName;
        }
        componentDidMount() {
            this._isMounted = true;
            this._isMounting = false;
            // Stop recording. For first render()
            stopRecordingGetsForComponent();
            this._isRendering = false;
        }
        componentDidUpdate() {
            // Stop recording. For not-first render()
            stopRecordingGetsForComponent();
            this._isRendering = false;
        }
        componentWillUnmount() {
            removeListenersForComponent(this);
            this._isMounted = false;
        }
        update() {
            // 1. If the component has already unmounted, don't try and set the state
            // 2. The component might not have mounted YET, but is in the middle of its first
            //    render cycle.
            //    For example, if a user sets store.loading to true in App.componentDidMount
            if (this._isMounted || this._isMounting) {
                this.setState({ store: getStoreClone() });
            }
        }
        render() {
            if (!this._isRendering) {
                startRecordingGetsForComponent(this);
                this._isRendering = true;
            }
            const props = Object.assign(Object.assign({}, this.props), { store: this.state.store });
            return React$1.createElement(ComponentToWrap, Object.assign({}, props));
        }
    }
    WrappedComponent.displayName = `Collected(${componentName})`;
    // @ts-ignore - I can't work this out
    return hoistNonReactStatics$1(WrappedComponent, ComponentToWrap);
};

export default collect;
