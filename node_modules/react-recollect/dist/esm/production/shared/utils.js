import { PATH } from './constants.js';
import state$1 from './state.js';

// 'object' meaning 'plain object'.
const isObject = (item) => !!item && typeof item === 'object' && item.constructor === Object;
const isArray = (item) => Array.isArray(item);
const isMap = (item) => item instanceof Map;
const isSet = (item) => item instanceof Set;
// A target is one of the four types that Recollect will proxy
const isTarget = (item) => isObject(item) || isArray(item) || isMap(item) || isSet(item);
// This is internal to JS or to Recollect
const isInternal = (prop) => prop === PATH ||
    prop === 'constructor' ||
    prop === 'toJSON' ||
    // Various type-checking libraries call these
    prop === '@@toStringTag' ||
    prop === Symbol.toStringTag;
const isFunction = (item) => typeof item === 'function';
const isArrayMutation = (target, prop) => isArray(target) &&
    [
        "copyWithin" /* CopyWithin */,
        "fill" /* Fill */,
        "pop" /* Pop */,
        "push" /* Push */,
        "reverse" /* Reverse */,
        "shift" /* Shift */,
        "sort" /* Sort */,
        "splice" /* Splice */,
        "unshift" /* Unshift */,
    ].includes(prop);
const clone = (target) => {
    if (isObject(target))
        return Object.assign({}, target);
    // @ts-ignore
    if (isArray(target))
        return target.slice();
    // @ts-ignore
    if (isMap(target))
        return new Map(target);
    // @ts-ignore
    if (isSet(target))
        return new Set(target);
    return target;
};
/**
 * Get the value from an object. This is for end-user objects. E.g. not
 * accessing a symbol property on a Map object.
 */
const getValue = (target, prop) => {
    if (isMap(target))
        return target.get(prop);
    if (isSet(target))
        return prop;
    if (isArray(target))
        return target[prop];
    return target[prop];
};
const setValue = (mutableTarget, prop, value) => {
    if (isObject(mutableTarget)) {
        mutableTarget[prop] = value;
    }
    else if (isArray(mutableTarget)) {
        // @ts-ignore - is fine, prop can be a symbol
        mutableTarget[prop] = value;
    }
    else if (isMap(mutableTarget)) {
        // @ts-ignore
        mutableTarget.set(prop, value);
    }
    else if (isSet(mutableTarget)) {
        // @ts-ignore
        mutableTarget.add(value);
    }
    else {
        throw Error('Unexpected type');
    }
};
const getSize = (item) => {
    if (isObject(item))
        return Object.keys(item).length;
    // @ts-ignore - TS thinks item is never
    if (isArray(item))
        return item.length;
    // @ts-ignore - TS thinks item is never
    if (isMap(item) || isSet(item))
        return item.size;
    throw Error('Unexpected type');
};
/**
 * Shallow replaces the contents of one object with the contents of another.
 * The top level object will remain the same, but all changed content will
 * be replaced with the new content.
 */
const replaceObject = (mutableTarget, nextObject) => {
    if (nextObject) {
        // From the new data, add to the old data anything that's new
        // (from the top level props only)
        Object.entries(nextObject).forEach(([prop, value]) => {
            if (mutableTarget[prop] !== value) {
                mutableTarget[prop] = value;
            }
        });
        // Clear out any keys that aren't in the new data
        Object.keys(mutableTarget).forEach((prop) => {
            if (!(prop in nextObject)) {
                delete mutableTarget[prop];
            }
        });
    }
    else {
        // Just empty the old object
        Object.keys(mutableTarget).forEach((prop) => {
            delete mutableTarget[prop];
        });
    }
};
/**
 * Traverse a tree, calling a callback for each node with the item and the path.
 * This can either mutate each value, or return a new value to create a clone.
 * @example const clone = utils.updateDeep(original, utils.clone);
 * Only traverses the targets supported by Recollect.
 */
const updateDeep = (mutableTarget, updater) => {
    const path = [];
    const processLevel = (target) => {
        const updated = updater(target, path.slice());
        // If the updater returns something, use it. Else mutate the original.
        const next = typeof updated !== 'undefined' ? updated : target;
        const handleEntry = (prop, value) => {
            path.push(prop);
            const processed = processLevel(value);
            path.pop();
            setValue(next, prop, processed);
        };
        if (isObject(next)) {
            Object.entries(next).forEach(([prop, value]) => {
                handleEntry(prop, value);
            });
        }
        else if (isArray(next) || isMap(next)) {
            next.forEach((value, prop) => {
                handleEntry(prop, value);
            });
        }
        else if (isSet(next)) {
            // A set is special - you can't reassign what's in a particular
            // 'position' like the other three, so we do some fancy footwork...
            const setContents = Array.from(next);
            next.clear();
            setContents.forEach((value) => {
                handleEntry(value, value);
            });
        }
        return next;
    };
    return processLevel(mutableTarget);
};
/**
 * Does some work while the proxy is muted. Returns the result of the
 * callback as a convenience.
 * This prevents components from being subscribed to reads from the store,
 * it does not prevent updates being triggered.
 */
const whileMuted = (cb) => {
    state$1.proxyIsMuted = true;
    const result = cb();
    state$1.proxyIsMuted = false;
    return result;
};
/**
 * This is a convenience method that triggers a read on each item in the array.
 * When used during the render cycle of a collected component, it has the
 * side-effect of subscribing that component to each item in the array.
 */
const useProps = (props) => {
    // useProps must never return, so it can be used in the body of a component
    props.includes(0);
};

export { clone, getSize, getValue, isArray, isArrayMutation, isFunction, isInternal, isMap, isObject, isSet, isTarget, replaceObject, setValue, updateDeep, useProps, whileMuted };
