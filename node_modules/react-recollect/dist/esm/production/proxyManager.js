import { ORIGINAL } from './shared/constants.js';
import state$1 from './shared/state.js';
import { isMap, isSet, isFunction, isInternal, isArrayMutation, isArray, updateDeep, isTarget } from './shared/utils.js';
import { extend, get, makeInternalString, addProp } from './shared/paths.js';
import { logGet, logDelete, logSet } from './shared/debug.js';
import { dispatchUpdateInNextStore } from './shared/pubSub.js';

/**
 * Add a new listener to be notified when a particular value in the store changes
 * To be used when a component reads from a property.
 */
const addListener = (propPath) => {
    if (!state$1.currentComponent)
        return;
    // We use a string instead of an array because it's much easier to match
    const pathString = makeInternalString(propPath);
    const components = state$1.listeners.get(pathString) || new Set();
    components.add(state$1.currentComponent);
    state$1.listeners.set(pathString, components);
};
/**
 * These are the proxy handlers. Notes:
 * * We have different handlers (different traps) for object/array and
 *    map/set.
 * * When the proxy is muted, use Reflect[trap] and bypass any logic. The
 *    exception is Map/Set methods, where we must bind `this` first
 * * `ORIGINAL` lets us unwrap a proxied object
 * * We redirect to the 'next version' of a target if it has been changed
 */
const getHandlerForObject = (targetObject) => {
    if (isMap(targetObject) || isSet(targetObject)) {
        // Map() and Set() get a special handler, because reads and writes all
        // happen in the get() trap (different to the get() method of the map/set!)
        return {
            get(target, prop) {
                if (prop === ORIGINAL)
                    return target;
                let result = Reflect.get(target, prop);
                // The innards of Map and Set require this binding
                if (isFunction(result))
                    result = result.bind(target);
                // Bail early for some things. Unlike objects/arrays, we will
                // continue on even if !state.currentComponent
                if (state$1.proxyIsMuted || isInternal(prop)) {
                    return result;
                }
                if (!state$1.currentComponent && state$1.redirectToNext) {
                    const nextVersion = state$1.nextVersionMap.get(target);
                    if (nextVersion)
                        return Reflect.get(nextVersion, prop);
                }
                // Adding to a Map
                if (prop === "set" /* Set */) {
                    const handler = {
                        apply(func, applyTarget, [key, value]) {
                            if (applyTarget.get(key) === value)
                                return true; // No change, no need to carry on
                            return dispatchUpdateInNextStore({
                                target: applyTarget,
                                prop: key,
                                value,
                                updater: (finalTarget, newProxiedValue) => {
                                    logSet(target, prop, newProxiedValue);
                                    // We call the map.set() now, but on the item in the
                                    // store, and with the new args
                                    return Reflect.apply(finalTarget[prop], finalTarget, [
                                        key,
                                        newProxiedValue,
                                    ]);
                                },
                            });
                        },
                    };
                    return new Proxy(result, handler);
                }
                // Adding to a Set
                if (prop === "add" /* Add */) {
                    const handler = {
                        apply(func, applyTarget, [value]) {
                            if (applyTarget.has(value))
                                return true; // Would be a no op
                            return dispatchUpdateInNextStore({
                                target: applyTarget,
                                notifyTarget: true,
                                value,
                                updater: (finalTarget, newProxiedValue) => {
                                    logSet(target, prop, newProxiedValue);
                                    return Reflect.apply(finalTarget[prop], finalTarget, [
                                        newProxiedValue,
                                    ]);
                                },
                            });
                        },
                    };
                    return new Proxy(result, handler);
                }
                // On either a Set or Map
                if (prop === "clear" /* Clear */ || prop === "delete" /* Delete */) {
                    const handler = {
                        apply(func, applyTarget, [key]) {
                            if (!applyTarget.size ||
                                (prop === "delete" /* Delete */ && !applyTarget.has(key))) {
                                return false; // false indicates no change
                            }
                            return dispatchUpdateInNextStore({
                                target: applyTarget,
                                notifyTarget: true,
                                updater: (finalTarget) => {
                                    logSet(target, prop);
                                    return Reflect.apply(finalTarget[prop], finalTarget, [key]);
                                },
                            });
                        },
                    };
                    return new Proxy(result, handler);
                }
                // Now that we've handled any modifying methods, we can
                // just return the result if we're not in the render cycle.
                if (!state$1.currentComponent)
                    return result;
                // If we're reading a particular value, we'll want a listener for that
                // We don't listen on `.has` because any change that would result in
                // `.has` returning a different value would update the target
                if (isMap(target) && prop === "get" /* Get */) {
                    const handler = {
                        apply(func, applyTarget, args) {
                            addListener(extend(target, args[0]));
                            return Reflect.apply(func, applyTarget, args);
                        },
                    };
                    return new Proxy(result, handler);
                }
                // For all other read operations, just return
                return result;
            },
        };
    }
    return {
        get(target, prop) {
            // This allows getting the un-proxied version of a proxied object
            if (prop === ORIGINAL)
                return target;
            const result = Reflect.get(target, prop);
            if (state$1.proxyIsMuted || isInternal(prop))
                return result;
            // Mutating array methods make a lot of noise, so we wrap them in a proxy
            // Only one update will be fired - for the actual array.
            if (isArrayMutation(target, prop)) {
                const handler = {
                    apply(func, applyTarget, args) {
                        return dispatchUpdateInNextStore({
                            target: applyTarget,
                            notifyTarget: true,
                            value: args,
                            updater: (finalTarget, proxiedArgs) => {
                                logSet(target, prop, proxiedArgs);
                                const updateResult = Reflect.apply(
                                // @ts-ignore - Yes, symbol CAN be used as an index type
                                finalTarget[prop], finalTarget, proxiedArgs);
                                const rootPath = get(target);
                                // At this point, the array is updated. But the paths of the
                                // items could be wrong, so we refresh them.
                                updateDeep(finalTarget, (item, path) => {
                                    if (isTarget(item)) {
                                        addProp(item, [...rootPath, ...path]);
                                    }
                                });
                                return updateResult;
                            },
                        });
                    },
                };
                return new Proxy(result, handler);
            }
            // For all other methods (.join, .toString(), etc) return the function
            // @ts-ignore - wrong, symbol can be used an an index type
            if (isFunction(target[prop]))
                return result;
            if (state$1.currentComponent) {
                // We record a get if a component is rendering, with the exception
                // of reading array length. This would be redundant, since changes to
                // length trigger a change on the array itself
                if (!(isArray(target) && prop === "length" /* Length */)) {
                    logGet(target, prop, result);
                    addListener(extend(target, prop));
                }
            }
            else if (state$1.redirectToNext) {
                // When we're outside the render cycle, we route
                // requests to the 'next version'
                // Note, this will result in another get(), but on the equivalent
                // target from the next store. muteProxy will be set so this line
                // isn't triggered in an infinite loop
                const nextVersion = state$1.nextVersionMap.get(target);
                if (nextVersion)
                    return Reflect.get(nextVersion, prop);
            }
            return result;
        },
        has(target, prop) {
            const result = Reflect.has(target, prop);
            if (state$1.proxyIsMuted || isInternal(prop))
                return result;
            if (state$1.currentComponent) {
                // Arrays use `has` too, but we capture a listener elsewhere for that.
                // Here we only want to capture access to objects
                if (!isArray(target)) {
                    logGet(target, prop);
                    addListener(extend(target, prop));
                }
            }
            else {
                const nextVersion = state$1.nextVersionMap.get(target);
                if (nextVersion)
                    return Reflect.has(nextVersion, prop);
            }
            return result;
        },
        ownKeys(target) {
            const result = Reflect.ownKeys(target);
            if (state$1.proxyIsMuted)
                return result;
            if (state$1.currentComponent) {
                logGet(target);
                addListener(get(target));
            }
            else {
                const nextVersion = state$1.nextVersionMap.get(target);
                if (nextVersion)
                    return Reflect.ownKeys(nextVersion);
            }
            return result;
        },
        set(target, prop, value) {
            if (state$1.proxyIsMuted)
                return Reflect.set(target, prop, value);
            // If there's no change, we return
            // @ts-ignore - target[prop] is fine
            if (target[prop] === value)
                return true;
            return dispatchUpdateInNextStore({
                target,
                prop,
                value,
                updater: (finalTarget, newValueProxy) => {
                    logSet(target, prop, newValueProxy);
                    return Reflect.set(finalTarget, prop, newValueProxy);
                },
            });
        },
        deleteProperty(target, prop) {
            if (state$1.proxyIsMuted)
                return Reflect.deleteProperty(target, prop);
            return dispatchUpdateInNextStore({
                target,
                prop,
                notifyTarget: true,
                updater: (finalTarget) => {
                    logDelete(target, prop);
                    return Reflect.deleteProperty(finalTarget, prop);
                },
            });
        },
    };
};
/**
 * Wrap an item in a proxy
 */
const createShallow = (target) => {
    return new Proxy(target, getHandlerForObject(target));
};

export { createShallow, getHandlerForObject };
