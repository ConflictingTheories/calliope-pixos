import { LS_KEYS } from './constants.js';
import state$1 from './state.js';
import { getValue } from './utils.js';
import { extendToUserString, internalToUser } from './paths.js';
import { get, set } from './ls.js';

const DEBUG_ON = 'on';
const DEBUG_OFF = 'off';
let DEBUG = get(LS_KEYS.RR_DEBUG) || DEBUG_OFF;
if (DEBUG === DEBUG_ON) {
    console.info('Recollect debugging is enabled. Type __RR__.debugOff() to turn it off.');
}
const debugOn = () => {
    DEBUG = DEBUG_ON;
    set(LS_KEYS.RR_DEBUG, DEBUG_ON);
};
const debugOff = () => {
    DEBUG = DEBUG_OFF;
    set(LS_KEYS.RR_DEBUG, DEBUG_OFF);
};
const debug = (cb) => {
    if (DEBUG === DEBUG_ON)
        cb();
};
const logGet = (target, prop, value) => {
    debug(() => {
        console.groupCollapsed(`GET: ${extendToUserString(target, prop)}`);
        console.info(`Component: <${state$1.currentComponent._name}>`);
        if (typeof value !== 'undefined') {
            console.info('Value:', value);
        }
        console.groupEnd();
    });
};
const logSet = (target, prop, value) => {
    debug(() => {
        console.groupCollapsed(`SET: ${extendToUserString(target, prop)}`);
        console.info('From:', getValue(target, prop));
        console.info('To:  ', value);
        console.groupEnd();
    });
};
const logDelete = (target, prop) => {
    debug(() => {
        console.groupCollapsed(`DELETE: ${extendToUserString(target, prop)}`);
        console.info('Property: ', extendToUserString(target, prop));
        console.groupEnd();
    });
};
const logUpdate = (component, propsUpdated) => {
    debug(() => {
        console.groupCollapsed(`UPDATE:  <${component._name}>`);
        console.info('Changed properties:', propsUpdated);
        console.groupEnd();
    });
};
const getComponentsAndListeners = (componentFirst, matcher, makeName) => {
    const result = {};
    Array.from(state$1.listeners).forEach(([path, componentSet]) => {
        componentSet.forEach((component) => {
            var _a;
            let componentName = component._name;
            if (makeName) {
                componentName += (_a = makeName(component.props)) !== null && _a !== void 0 ? _a : '';
            }
            const userPath = internalToUser(path);
            const prop = componentFirst ? componentName : userPath;
            const value = componentFirst ? userPath : componentName;
            if (matcher && !prop.match(matcher))
                return;
            if (!result[prop])
                result[prop] = [];
            if (!result[prop].includes(value))
                result[prop].push(value);
        });
    });
    return result;
};
/**
 * Return an object where the keys are component names and the values are
 * arrays of the store properties the component is subscribed to
 */
const getListenersByComponent = (matcher, makeName) => getComponentsAndListeners(true, matcher, makeName);
/**
 * Return an object where the keys are store properties and the values are
 * the names of the components that listen to the property
 */
const getComponentsByListener = (matcher, makeName) => getComponentsAndListeners(false, matcher, makeName);

export { debug, debugOff, debugOn, getComponentsByListener, getListenersByComponent, logDelete, logGet, logSet, logUpdate };
