import { ORIGINAL } from './shared/constants.js';
import state$1 from './shared/state.js';
import { replaceObject, whileMuted, getSize, isTarget, updateDeep, clone, getValue, setValue } from './shared/utils.js';
import { get, extend, addProp } from './shared/paths.js';
import { onUpdateInNextStore } from './shared/pubSub.js';
import { createShallow } from './proxyManager.js';
import { flushUpdates, notifyByPath } from './updateManager.js';

/**
 * This is the store, as exported to the user. When the store is passed to a
 * component, it is shallow cloned. This leaves us free to mutate the root
 * level directly.
 */
state$1.store = createShallow({});
/**
 * Deep update the store, the following rules are followed:
 * - If updating the root level, the store object itself is mutated.
 * - For any other (deep) update we clone each node along the path to
 *   the target to update (the target is cloned too).
 */
const updateStore = ({ target, prop, value, notifyTarget = false, updater, }) => whileMuted(() => {
    let result;
    // This function doesn't know anything about the prop being set.
    // It just finds the target (the parent of the prop) and
    // calls updater() with it.
    const targetPath = get(target);
    // Note that if this update is a method (e.g. arr.push()) then prop can be
    // undefined, meaning the prop path won't be extended, and will just be
    // the path of the target (the array) which is correct.
    const propPath = extend(target, prop);
    // If we change the length/size of an array/map/set, we will want to
    // trigger a render of the parent path.
    let targetChangedSize = false;
    const initialSize = getSize(target);
    let newValue = value;
    // Make sure the new value is deeply wrapped in proxies, if it's a target
    if (isTarget(newValue)) {
        newValue = updateDeep(value, (item, thisPropPath) => {
            if (!isTarget(item))
                return item;
            const next = clone(item);
            addProp(next, [...propPath, ...thisPropPath]);
            return createShallow(next);
        });
    }
    if (!targetPath.length) {
        // If the target is the store root, it's mutated in place.
        result = updater(state$1.store, newValue);
        targetChangedSize = getSize(state$1.store) !== initialSize;
    }
    else {
        targetPath.reduce((item, thisProp, i) => {
            const thisValue = getValue(item, thisProp);
            // Shallow clone this level
            let clone$1 = clone(thisValue);
            addProp(clone$1, get(thisValue));
            // Wrap the clone in a proxy
            clone$1 = createShallow(clone$1);
            // Mutate this level (swap out the original for the clone)
            setValue(item, thisProp, clone$1);
            // If we're at the end of the path, then 'clone' is our target
            if (i === targetPath.length - 1) {
                result = updater(clone$1, newValue);
                targetChangedSize = getSize(clone$1) !== initialSize;
                // We keep a reference between the original target and the clone
                // `target` may or may not be wrapped in a proxy (Maps and Sets are)
                // So we check/get the unproxied version
                state$1.nextVersionMap.set(target[ORIGINAL] || target, clone$1);
            }
            return clone$1;
        }, state$1.store);
    }
    // If the 'size' of a target changes, it's reasonable to assume that
    // users of the target are going to need to re-render, else use the prop
    const notifyPath = notifyTarget || targetChangedSize ? targetPath : propPath;
    notifyByPath(notifyPath);
    return result;
});
onUpdateInNextStore(updateStore);
/**
 * Executes the provided function, then updates appropriate components and calls
 * listeners registered with `afterChange()`. Guaranteed to only trigger one
 * update. The provided function must only contain synchronous code.
 */
const batch = (cb) => {
    state$1.isBatchUpdating = true;
    cb();
    state$1.isBatchUpdating = false;
    flushUpdates();
};
/**
 * Empty the Recollect store and replace it with new data.
 */
const initStore = (data) => {
    batch(() => {
        replaceObject(state$1.store, data);
    });
};

export { batch, initStore, updateStore };
