'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ReactDOM = _interopDefault(require('react-dom'));
var React = _interopDefault(require('react'));
var hoistNonReactStatics = _interopDefault(require('hoist-non-react-statics'));
var OriginalPropTypes = require('prop-types');

/**
 * To convert the path array to a string for the listener keys
 * Use a crazy separator. If the separator was a '.', and the user had a prop with a dot in it,
 * then it could cause false matches in the updated logic.
 */
const PROP_PATH_SEP = '~~~';
const PATH = Symbol('PATH');
const ORIGINAL = Symbol('ORIGINAL');
const LS_KEYS = {
    RR_HISTORY_LIMIT: 'RR_HISTORY_LIMIT',
    RR_DEBUG: 'RR_DEBUG',
};

/**
 * Any state shared between modules goes here
 * For internal use, not for consumers
 */
const state = {
    currentComponent: null,
    isBatchUpdating: false,
    isInBrowser: typeof window !== 'undefined',
    listeners: new Map(),
    manualListeners: [],
    nextVersionMap: new WeakMap(),
    proxyIsMuted: false,
    redirectToNext: true,
    store: {},
};

// 'object' meaning 'plain object'.
const isObject = (item) => !!item && typeof item === 'object' && item.constructor === Object;
const isArray = (item) => Array.isArray(item);
const isMap = (item) => item instanceof Map;
const isSet = (item) => item instanceof Set;
// A target is one of the four types that Recollect will proxy
const isTarget = (item) => isObject(item) || isArray(item) || isMap(item) || isSet(item);
// This is internal to JS or to Recollect
const isInternal = (prop) => prop === PATH ||
    prop === 'constructor' ||
    prop === 'toJSON' ||
    // Various type-checking libraries call these
    prop === '@@toStringTag' ||
    prop === Symbol.toStringTag;
const isFunction = (item) => typeof item === 'function';
const isArrayMutation = (target, prop) => isArray(target) &&
    [
        "copyWithin" /* CopyWithin */,
        "fill" /* Fill */,
        "pop" /* Pop */,
        "push" /* Push */,
        "reverse" /* Reverse */,
        "shift" /* Shift */,
        "sort" /* Sort */,
        "splice" /* Splice */,
        "unshift" /* Unshift */,
    ].includes(prop);
const clone = (target) => {
    if (isObject(target))
        return Object.assign({}, target);
    // @ts-ignore
    if (isArray(target))
        return target.slice();
    // @ts-ignore
    if (isMap(target))
        return new Map(target);
    // @ts-ignore
    if (isSet(target))
        return new Set(target);
    return target;
};
/**
 * Get the value from an object. This is for end-user objects. E.g. not
 * accessing a symbol property on a Map object.
 */
const getValue = (target, prop) => {
    if (isMap(target))
        return target.get(prop);
    if (isSet(target))
        return prop;
    if (isArray(target))
        return target[prop];
    return target[prop];
};
const setValue = (mutableTarget, prop, value) => {
    if (isObject(mutableTarget)) {
        mutableTarget[prop] = value;
    }
    else if (isArray(mutableTarget)) {
        // @ts-ignore - is fine, prop can be a symbol
        mutableTarget[prop] = value;
    }
    else if (isMap(mutableTarget)) {
        // @ts-ignore
        mutableTarget.set(prop, value);
    }
    else if (isSet(mutableTarget)) {
        // @ts-ignore
        mutableTarget.add(value);
    }
    else {
        throw Error('Unexpected type');
    }
};
const getSize = (item) => {
    if (isObject(item))
        return Object.keys(item).length;
    // @ts-ignore - TS thinks item is never
    if (isArray(item))
        return item.length;
    // @ts-ignore - TS thinks item is never
    if (isMap(item) || isSet(item))
        return item.size;
    throw Error('Unexpected type');
};
/**
 * Shallow replaces the contents of one object with the contents of another.
 * The top level object will remain the same, but all changed content will
 * be replaced with the new content.
 */
const replaceObject = (mutableTarget, nextObject) => {
    if (nextObject) {
        // From the new data, add to the old data anything that's new
        // (from the top level props only)
        Object.entries(nextObject).forEach(([prop, value]) => {
            if (mutableTarget[prop] !== value) {
                mutableTarget[prop] = value;
            }
        });
        // Clear out any keys that aren't in the new data
        Object.keys(mutableTarget).forEach((prop) => {
            if (!(prop in nextObject)) {
                delete mutableTarget[prop];
            }
        });
    }
    else {
        // Just empty the old object
        Object.keys(mutableTarget).forEach((prop) => {
            delete mutableTarget[prop];
        });
    }
};
/**
 * Traverse a tree, calling a callback for each node with the item and the path.
 * This can either mutate each value, or return a new value to create a clone.
 * @example const clone = utils.updateDeep(original, utils.clone);
 * Only traverses the targets supported by Recollect.
 */
const updateDeep = (mutableTarget, updater) => {
    const path = [];
    const processLevel = (target) => {
        const updated = updater(target, path.slice());
        // If the updater returns something, use it. Else mutate the original.
        const next = typeof updated !== 'undefined' ? updated : target;
        const handleEntry = (prop, value) => {
            path.push(prop);
            const processed = processLevel(value);
            path.pop();
            setValue(next, prop, processed);
        };
        if (isObject(next)) {
            Object.entries(next).forEach(([prop, value]) => {
                handleEntry(prop, value);
            });
        }
        else if (isArray(next) || isMap(next)) {
            next.forEach((value, prop) => {
                handleEntry(prop, value);
            });
        }
        else if (isSet(next)) {
            // A set is special - you can't reassign what's in a particular
            // 'position' like the other three, so we do some fancy footwork...
            const setContents = Array.from(next);
            next.clear();
            setContents.forEach((value) => {
                handleEntry(value, value);
            });
        }
        return next;
    };
    return processLevel(mutableTarget);
};
/**
 * Does some work while the proxy is muted. Returns the result of the
 * callback as a convenience.
 * This prevents components from being subscribed to reads from the store,
 * it does not prevent updates being triggered.
 */
const whileMuted = (cb) => {
    state.proxyIsMuted = true;
    const result = cb();
    state.proxyIsMuted = false;
    return result;
};
/**
 * This is a convenience method that triggers a read on each item in the array.
 * When used during the render cycle of a collected component, it has the
 * side-effect of subscribing that component to each item in the array.
 */
const useProps = (props) => {
    // useProps must never return, so it can be used in the body of a component
    props.includes(0);
};

// Joins an array that potentially contains symbols, which need an explicit
// 'toString()'
const join = (arr, joiner) => arr.map((item) => item.toString()).join(joiner);
/**
 * Convert a target and a prop into a user-friendly string like store.tasks.1.done
 */
const makeUserString = (propPath) => join(propPath, '.');
const makeInternalString = (propPath) => join(propPath, PROP_PATH_SEP);
/**
 * Takes the path stored in an object, and a new prop, and returns the two
 * combined
 */
const extend = (target, prop) => {
    const basePath = target[PATH] || [];
    if (typeof prop === 'undefined')
        return basePath;
    return basePath.concat(prop);
};
/**
 * Convert a target and a prop into a user-friendly string like store.tasks.1.done
 */
const extendToUserString = (target, prop) => makeUserString(extend(target, prop));
const addProp = (target, propPath) => {
    if (!target)
        return;
    Object.defineProperty(target, PATH, {
        value: propPath,
        writable: true,
    });
};
const get = (target) => target[PATH] || [];

const hasLocalStorage = typeof window !== 'undefined' && !!window.localStorage;
const set = (key, data) => {
    if (!hasLocalStorage)
        return undefined;
    try {
        const string = typeof data === 'string' ? data : JSON.stringify(data);
        return localStorage.setItem(key, string);
    }
    catch (err) {
        return undefined;
    }
};
const get$1 = (key) => {
    if (!hasLocalStorage)
        return undefined;
    const data = localStorage.getItem(key);
    if (!data)
        return data;
    try {
        return JSON.parse(data);
    }
    catch (err) {
        // So we return whatever we've got on a failure
        // E.g. the data could be a plain string, which errors on JSON.parse.
        return data;
    }
};

const DEBUG_ON = 'on';
const DEBUG_OFF = 'off';
let DEBUG = get$1(LS_KEYS.RR_DEBUG) || DEBUG_OFF;
if (DEBUG === DEBUG_ON) {
    console.info('Recollect debugging is enabled. Type __RR__.debugOff() to turn it off.');
}
const debugOn = () => {
    DEBUG = DEBUG_ON;
    set(LS_KEYS.RR_DEBUG, DEBUG_ON);
};
const debugOff = () => {
    DEBUG = DEBUG_OFF;
    set(LS_KEYS.RR_DEBUG, DEBUG_OFF);
};
const debug = (cb) => {
    if (DEBUG === DEBUG_ON)
        cb();
};
const logGet = (target, prop, value) => {
    debug(() => {
        console.groupCollapsed(`GET: ${extendToUserString(target, prop)}`);
        console.info(`Component: <${state.currentComponent._name}>`);
        if (typeof value !== 'undefined') {
            console.info('Value:', value);
        }
        console.groupEnd();
    });
};
const logSet = (target, prop, value) => {
    debug(() => {
        console.groupCollapsed(`SET: ${extendToUserString(target, prop)}`);
        console.info('From:', getValue(target, prop));
        console.info('To:  ', value);
        console.groupEnd();
    });
};
const logDelete = (target, prop) => {
    debug(() => {
        console.groupCollapsed(`DELETE: ${extendToUserString(target, prop)}`);
        console.info('Property: ', extendToUserString(target, prop));
        console.groupEnd();
    });
};
const logUpdate = (component, propsUpdated) => {
    debug(() => {
        console.groupCollapsed(`UPDATE:  <${component._name}>`);
        console.info('Changed properties:', propsUpdated);
        console.groupEnd();
    });
};

const subscribers = {};
const onUpdateInNextStore = (func) => {
    subscribers["UpdateNextStore" /* UpdateNextStore */] = func;
};
const dispatchUpdateInNextStore = (data) => {
    return subscribers["UpdateNextStore" /* UpdateNextStore */](data);
};
/**
 * Add a callback to be called every time the store changes
 */
const afterChange = (cb) => {
    state.manualListeners.push(cb);
};

/**
 * Add a new listener to be notified when a particular value in the store changes
 * To be used when a component reads from a property.
 */
const addListener = (propPath) => {
    if (!state.currentComponent)
        return;
    // We use a string instead of an array because it's much easier to match
    const pathString = makeInternalString(propPath);
    const components = state.listeners.get(pathString) || new Set();
    components.add(state.currentComponent);
    state.listeners.set(pathString, components);
};
/**
 * These are the proxy handlers. Notes:
 * * We have different handlers (different traps) for object/array and
 *    map/set.
 * * When the proxy is muted, use Reflect[trap] and bypass any logic. The
 *    exception is Map/Set methods, where we must bind `this` first
 * * `ORIGINAL` lets us unwrap a proxied object
 * * We redirect to the 'next version' of a target if it has been changed
 */
const getHandlerForObject = (targetObject) => {
    if (isMap(targetObject) || isSet(targetObject)) {
        // Map() and Set() get a special handler, because reads and writes all
        // happen in the get() trap (different to the get() method of the map/set!)
        return {
            get(target, prop) {
                if (prop === ORIGINAL)
                    return target;
                let result = Reflect.get(target, prop);
                // The innards of Map and Set require this binding
                if (isFunction(result))
                    result = result.bind(target);
                // Bail early for some things. Unlike objects/arrays, we will
                // continue on even if !state.currentComponent
                if (state.proxyIsMuted || isInternal(prop)) {
                    return result;
                }
                if (!state.currentComponent && state.redirectToNext) {
                    const nextVersion = state.nextVersionMap.get(target);
                    if (nextVersion)
                        return Reflect.get(nextVersion, prop);
                }
                // Adding to a Map
                if (prop === "set" /* Set */) {
                    const handler = {
                        apply(func, applyTarget, [key, value]) {
                            if (applyTarget.get(key) === value)
                                return true; // No change, no need to carry on
                            return dispatchUpdateInNextStore({
                                target: applyTarget,
                                prop: key,
                                value,
                                updater: (finalTarget, newProxiedValue) => {
                                    logSet(target, prop, newProxiedValue);
                                    // We call the map.set() now, but on the item in the
                                    // store, and with the new args
                                    return Reflect.apply(finalTarget[prop], finalTarget, [
                                        key,
                                        newProxiedValue,
                                    ]);
                                },
                            });
                        },
                    };
                    return new Proxy(result, handler);
                }
                // Adding to a Set
                if (prop === "add" /* Add */) {
                    const handler = {
                        apply(func, applyTarget, [value]) {
                            if (applyTarget.has(value))
                                return true; // Would be a no op
                            return dispatchUpdateInNextStore({
                                target: applyTarget,
                                notifyTarget: true,
                                value,
                                updater: (finalTarget, newProxiedValue) => {
                                    logSet(target, prop, newProxiedValue);
                                    return Reflect.apply(finalTarget[prop], finalTarget, [
                                        newProxiedValue,
                                    ]);
                                },
                            });
                        },
                    };
                    return new Proxy(result, handler);
                }
                // On either a Set or Map
                if (prop === "clear" /* Clear */ || prop === "delete" /* Delete */) {
                    const handler = {
                        apply(func, applyTarget, [key]) {
                            if (!applyTarget.size ||
                                (prop === "delete" /* Delete */ && !applyTarget.has(key))) {
                                return false; // false indicates no change
                            }
                            return dispatchUpdateInNextStore({
                                target: applyTarget,
                                notifyTarget: true,
                                updater: (finalTarget) => {
                                    logSet(target, prop);
                                    return Reflect.apply(finalTarget[prop], finalTarget, [key]);
                                },
                            });
                        },
                    };
                    return new Proxy(result, handler);
                }
                // Now that we've handled any modifying methods, we can
                // just return the result if we're not in the render cycle.
                if (!state.currentComponent)
                    return result;
                // If we're reading a particular value, we'll want a listener for that
                // We don't listen on `.has` because any change that would result in
                // `.has` returning a different value would update the target
                if (isMap(target) && prop === "get" /* Get */) {
                    const handler = {
                        apply(func, applyTarget, args) {
                            addListener(extend(target, args[0]));
                            return Reflect.apply(func, applyTarget, args);
                        },
                    };
                    return new Proxy(result, handler);
                }
                // For all other read operations, just return
                return result;
            },
        };
    }
    return {
        get(target, prop) {
            // This allows getting the un-proxied version of a proxied object
            if (prop === ORIGINAL)
                return target;
            const result = Reflect.get(target, prop);
            if (state.proxyIsMuted || isInternal(prop))
                return result;
            // Mutating array methods make a lot of noise, so we wrap them in a proxy
            // Only one update will be fired - for the actual array.
            if (isArrayMutation(target, prop)) {
                const handler = {
                    apply(func, applyTarget, args) {
                        return dispatchUpdateInNextStore({
                            target: applyTarget,
                            notifyTarget: true,
                            value: args,
                            updater: (finalTarget, proxiedArgs) => {
                                logSet(target, prop, proxiedArgs);
                                const updateResult = Reflect.apply(
                                // @ts-ignore - Yes, symbol CAN be used as an index type
                                finalTarget[prop], finalTarget, proxiedArgs);
                                const rootPath = get(target);
                                // At this point, the array is updated. But the paths of the
                                // items could be wrong, so we refresh them.
                                updateDeep(finalTarget, (item, path) => {
                                    if (isTarget(item)) {
                                        addProp(item, [...rootPath, ...path]);
                                    }
                                });
                                return updateResult;
                            },
                        });
                    },
                };
                return new Proxy(result, handler);
            }
            // For all other methods (.join, .toString(), etc) return the function
            // @ts-ignore - wrong, symbol can be used an an index type
            if (isFunction(target[prop]))
                return result;
            if (state.currentComponent) {
                // We record a get if a component is rendering, with the exception
                // of reading array length. This would be redundant, since changes to
                // length trigger a change on the array itself
                if (!(isArray(target) && prop === "length" /* Length */)) {
                    logGet(target, prop, result);
                    addListener(extend(target, prop));
                }
            }
            else if (state.redirectToNext) {
                // When we're outside the render cycle, we route
                // requests to the 'next version'
                // Note, this will result in another get(), but on the equivalent
                // target from the next store. muteProxy will be set so this line
                // isn't triggered in an infinite loop
                const nextVersion = state.nextVersionMap.get(target);
                if (nextVersion)
                    return Reflect.get(nextVersion, prop);
            }
            return result;
        },
        has(target, prop) {
            const result = Reflect.has(target, prop);
            if (state.proxyIsMuted || isInternal(prop))
                return result;
            if (state.currentComponent) {
                // Arrays use `has` too, but we capture a listener elsewhere for that.
                // Here we only want to capture access to objects
                if (!isArray(target)) {
                    logGet(target, prop);
                    addListener(extend(target, prop));
                }
            }
            else {
                const nextVersion = state.nextVersionMap.get(target);
                if (nextVersion)
                    return Reflect.has(nextVersion, prop);
            }
            return result;
        },
        ownKeys(target) {
            const result = Reflect.ownKeys(target);
            if (state.proxyIsMuted)
                return result;
            if (state.currentComponent) {
                logGet(target);
                addListener(get(target));
            }
            else {
                const nextVersion = state.nextVersionMap.get(target);
                if (nextVersion)
                    return Reflect.ownKeys(nextVersion);
            }
            return result;
        },
        set(target, prop, value) {
            if (state.proxyIsMuted)
                return Reflect.set(target, prop, value);
            // If there's no change, we return
            // @ts-ignore - target[prop] is fine
            if (target[prop] === value)
                return true;
            return dispatchUpdateInNextStore({
                target,
                prop,
                value,
                updater: (finalTarget, newValueProxy) => {
                    logSet(target, prop, newValueProxy);
                    return Reflect.set(finalTarget, prop, newValueProxy);
                },
            });
        },
        deleteProperty(target, prop) {
            if (state.proxyIsMuted)
                return Reflect.deleteProperty(target, prop);
            return dispatchUpdateInNextStore({
                target,
                prop,
                notifyTarget: true,
                updater: (finalTarget) => {
                    logDelete(target, prop);
                    return Reflect.deleteProperty(finalTarget, prop);
                },
            });
        },
    };
};
/**
 * Wrap an item in a proxy
 */
const createShallow = (target) => {
    return new Proxy(target, getHandlerForObject(target));
};

/* eslint-disable import/no-unresolved */
// unstable_batchedUpdates could be removed in a future major version
// So we'll provide a fallback
// https://github.com/facebook/react/issues/18602
var batchedUpdates = ReactDOM.unstable_batchedUpdates ||
    ((cb) => {
        cb();
    });

const queue = {
    components: new Map(),
    changedPaths: new Set(),
};
const flushUpdates = () => {
    // We batch updates here so that React will collect all setState() calls
    // (one for each component being updated) before triggering a render.
    // In other words: MANY .update() calls, ONE render.
    // This is subtly different to what the Recollect batch() function does -
    // it ensures that the listeners are only notified once for
    // multiple store changes
    // In other words: MANY store updates, ONE call to flushUpdates()
    batchedUpdates(() => {
        queue.components.forEach((propsUpdated, component) => {
            logUpdate(component, Array.from(propsUpdated));
            component.update();
        });
    });
    state.manualListeners.forEach((cb) => cb({
        changedProps: Array.from(queue.changedPaths),
        renderedComponents: Array.from(queue.components.keys()),
        store: state.store,
    }));
    queue.components.clear();
    queue.changedPaths.clear();
};
/**
 * Updates any component listening to:
 * - the exact propPath that has been changed. E.g. `tasks.2`
 * - a path further up the object tree. E.g. a component listening
 *   on `tasks.0` need to know if `tasks = 'foo'` happens
 * And if the path being notified is the top level (an empty path), everyone
 * gets updated.
 */
const notifyByPath = (propPath) => {
    const pathString = makeInternalString(propPath);
    const userFriendlyPropPath = makeUserString(propPath);
    queue.changedPaths.add(userFriendlyPropPath);
    state.listeners.forEach((components, listenerPath) => {
        if (pathString === '' || // Notify everyone for top-level changes
            pathString === listenerPath) {
            components.forEach((component) => {
                const propsUpdated = queue.components.get(component) || new Set();
                propsUpdated.add(userFriendlyPropPath);
                queue.components.set(component, propsUpdated);
            });
        }
    });
    // If we're not batch updating, flush the changes now, otherwise this
    // will be called when the batch is complete
    if (!state.isBatchUpdating)
        flushUpdates();
};
const removeListenersForComponent = (componentToRemove) => {
    state.listeners.forEach((components, listenerPath) => {
        const filteredComponents = Array.from(components).filter((existingComponent) => existingComponent !== componentToRemove);
        if (filteredComponents.length) {
            state.listeners.set(listenerPath, new Set(filteredComponents));
        }
        else {
            // If there are no components left listening, remove the path
            // For example, leaving a page will unmount a bunch of components
            state.listeners.delete(listenerPath);
        }
    });
};

/**
 * This is the store, as exported to the user. When the store is passed to a
 * component, it is shallow cloned. This leaves us free to mutate the root
 * level directly.
 */
state.store = createShallow({});
/**
 * Deep update the store, the following rules are followed:
 * - If updating the root level, the store object itself is mutated.
 * - For any other (deep) update we clone each node along the path to
 *   the target to update (the target is cloned too).
 */
const updateStore = ({ target, prop, value, notifyTarget = false, updater, }) => whileMuted(() => {
    let result;
    // This function doesn't know anything about the prop being set.
    // It just finds the target (the parent of the prop) and
    // calls updater() with it.
    const targetPath = get(target);
    // Note that if this update is a method (e.g. arr.push()) then prop can be
    // undefined, meaning the prop path won't be extended, and will just be
    // the path of the target (the array) which is correct.
    const propPath = extend(target, prop);
    // If we change the length/size of an array/map/set, we will want to
    // trigger a render of the parent path.
    let targetChangedSize = false;
    const initialSize = getSize(target);
    let newValue = value;
    // Make sure the new value is deeply wrapped in proxies, if it's a target
    if (isTarget(newValue)) {
        newValue = updateDeep(value, (item, thisPropPath) => {
            if (!isTarget(item))
                return item;
            const next = clone(item);
            addProp(next, [...propPath, ...thisPropPath]);
            return createShallow(next);
        });
    }
    if (!targetPath.length) {
        // If the target is the store root, it's mutated in place.
        result = updater(state.store, newValue);
        targetChangedSize = getSize(state.store) !== initialSize;
    }
    else {
        targetPath.reduce((item, thisProp, i) => {
            const thisValue = getValue(item, thisProp);
            // Shallow clone this level
            let clone$1 = clone(thisValue);
            addProp(clone$1, get(thisValue));
            // Wrap the clone in a proxy
            clone$1 = createShallow(clone$1);
            // Mutate this level (swap out the original for the clone)
            setValue(item, thisProp, clone$1);
            // If we're at the end of the path, then 'clone' is our target
            if (i === targetPath.length - 1) {
                result = updater(clone$1, newValue);
                targetChangedSize = getSize(clone$1) !== initialSize;
                // We keep a reference between the original target and the clone
                // `target` may or may not be wrapped in a proxy (Maps and Sets are)
                // So we check/get the unproxied version
                state.nextVersionMap.set(target[ORIGINAL] || target, clone$1);
            }
            return clone$1;
        }, state.store);
    }
    // If the 'size' of a target changes, it's reasonable to assume that
    // users of the target are going to need to re-render, else use the prop
    const notifyPath = notifyTarget || targetChangedSize ? targetPath : propPath;
    notifyByPath(notifyPath);
    return result;
});
onUpdateInNextStore(updateStore);
/**
 * Executes the provided function, then updates appropriate components and calls
 * listeners registered with `afterChange()`. Guaranteed to only trigger one
 * update. The provided function must only contain synchronous code.
 */
const batch = (cb) => {
    state.isBatchUpdating = true;
    cb();
    state.isBatchUpdating = false;
    flushUpdates();
};
/**
 * Empty the Recollect store and replace it with new data.
 */
const initStore = (data) => {
    batch(() => {
        replaceObject(state.store, data);
    });
};

// As we render down into a tree of collected components, we will start/stop
// recording
const componentStack = [];
const startRecordingGetsForComponent = (component) => {
    if (!state.isInBrowser)
        return;
    debug(() => {
        console.groupCollapsed(`RENDER: <${component._name}>`);
    });
    state.currentComponent = component;
    componentStack.push(state.currentComponent);
};
const stopRecordingGetsForComponent = () => {
    if (!state.isInBrowser)
        return;
    debug(() => {
        console.groupEnd();
    });
    componentStack.pop();
    state.currentComponent = componentStack[componentStack.length - 1] || null;
};
/**
 * This shallow clones the store to pass as state to the collected
 * component.
 */
const getStoreClone = () => whileMuted(() => {
    // We'll shallow clone the store so React knows it's new
    const shallowClone = Object.assign({}, state.store);
    // ... but redirect all reads to the real store
    state.nextVersionMap.set(shallowClone, state.store);
    return createShallow(shallowClone);
});
const collect = (ComponentToWrap) => {
    const componentName = ComponentToWrap.displayName || ComponentToWrap.name || 'NamelessComponent';
    class WrappedComponent extends React.PureComponent {
        constructor() {
            super(...arguments);
            this.state = {
                // This might be called by React when a parent component has updated with a new store,
                // we want this component (if it's a child) to have that next store as well.
                store: getStoreClone(),
            };
            // TODO (davidg) 2020-02-28: use private #isMounted, waiting on
            //  https://github.com/prettier/prettier/issues/7263
            this._isMounted = false;
            this._isMounting = true;
            // <React.StrictMode> will trigger multiple renders,
            // we must disregard these
            this._isRendering = false;
            this._name = componentName;
        }
        componentDidMount() {
            this._isMounted = true;
            this._isMounting = false;
            // Stop recording. For first render()
            stopRecordingGetsForComponent();
            this._isRendering = false;
        }
        componentDidUpdate() {
            // Stop recording. For not-first render()
            stopRecordingGetsForComponent();
            this._isRendering = false;
        }
        componentWillUnmount() {
            removeListenersForComponent(this);
            this._isMounted = false;
        }
        update() {
            // 1. If the component has already unmounted, don't try and set the state
            // 2. The component might not have mounted YET, but is in the middle of its first
            //    render cycle.
            //    For example, if a user sets store.loading to true in App.componentDidMount
            if (this._isMounted || this._isMounting) {
                this.setState({ store: getStoreClone() });
            }
        }
        render() {
            if (!this._isRendering) {
                startRecordingGetsForComponent(this);
                this._isRendering = true;
            }
            const props = Object.assign(Object.assign({}, this.props), { store: this.state.store });
            return React.createElement(ComponentToWrap, Object.assign({}, props));
        }
    }
    WrappedComponent.displayName = `Collected(${componentName})`;
    // @ts-ignore - I can't work this out
    return hoistNonReactStatics(WrappedComponent, ComponentToWrap);
};

let EnvPropTypes;
// In the dev build of Recollect, we wrap PropTypes in a proxy so we can
// mute the store while the prop types library reads the props.
{
    // For prod builds, just use the normal PropTypes which is a no-op
    EnvPropTypes = OriginalPropTypes;
}
// We do this so we're exporting a const (EnvPropTypes is a let)
const PropTypes = EnvPropTypes;

const { store } = state;
// `internals` is not part of the Recollect API. It is used by tests.
const internals = state;
if (typeof window !== 'undefined') {
    if ('Proxy' in window) {
        window.__RR__ = {
            debugOn,
            debugOff,
            internals: state,
        };
    }
    else {
        console.warn("This browser doesn't support the Proxy object, which react-recollect needs. See https://caniuse.com/#search=proxy to find out which browsers do support it");
    }
}

exports.PropTypes = PropTypes;
exports.afterChange = afterChange;
exports.batch = batch;
exports.collect = collect;
exports.initStore = initStore;
exports.internals = internals;
exports.store = store;
exports.useProps = useProps;
