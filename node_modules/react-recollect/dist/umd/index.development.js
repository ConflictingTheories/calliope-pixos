(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react-dom'), require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react-dom', 'react'], factory) :
  (global = global || self, factory(global.ReactRecollect = {}, global.ReactDOM, global.React));
}(this, (function (exports, ReactDOM, React) { 'use strict';

  ReactDOM = ReactDOM && Object.prototype.hasOwnProperty.call(ReactDOM, 'default') ? ReactDOM['default'] : ReactDOM;
  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  /**
   * To convert the path array to a string for the listener keys
   * Use a crazy separator. If the separator was a '.', and the user had a prop with a dot in it,
   * then it could cause false matches in the updated logic.
   */
  const PROP_PATH_SEP = '~~~';
  const PATH = Symbol('PATH');
  const ORIGINAL = Symbol('ORIGINAL');
  const LS_KEYS = {
      RR_HISTORY_LIMIT: 'RR_HISTORY_LIMIT',
      RR_DEBUG: 'RR_DEBUG',
  };

  /**
   * Any state shared between modules goes here
   * For internal use, not for consumers
   */
  const state = {
      currentComponent: null,
      isBatchUpdating: false,
      isInBrowser: typeof window !== 'undefined',
      listeners: new Map(),
      manualListeners: [],
      nextVersionMap: new WeakMap(),
      proxyIsMuted: false,
      redirectToNext: true,
      store: {},
  };

  // 'object' meaning 'plain object'.
  const isObject = (item) => !!item && typeof item === 'object' && item.constructor === Object;
  const isArray = (item) => Array.isArray(item);
  const isMap = (item) => item instanceof Map;
  const isSet = (item) => item instanceof Set;
  // A target is one of the four types that Recollect will proxy
  const isTarget = (item) => isObject(item) || isArray(item) || isMap(item) || isSet(item);
  // This is internal to JS or to Recollect
  const isInternal = (prop) => prop === PATH ||
      prop === 'constructor' ||
      prop === 'toJSON' ||
      // Various type-checking libraries call these
      prop === '@@toStringTag' ||
      prop === Symbol.toStringTag;
  const isFunction = (item) => typeof item === 'function';
  const isArrayMutation = (target, prop) => isArray(target) &&
      [
          "copyWithin" /* CopyWithin */,
          "fill" /* Fill */,
          "pop" /* Pop */,
          "push" /* Push */,
          "reverse" /* Reverse */,
          "shift" /* Shift */,
          "sort" /* Sort */,
          "splice" /* Splice */,
          "unshift" /* Unshift */,
      ].includes(prop);
  const clone = (target) => {
      if (isObject(target))
          return Object.assign({}, target);
      // @ts-ignore
      if (isArray(target))
          return target.slice();
      // @ts-ignore
      if (isMap(target))
          return new Map(target);
      // @ts-ignore
      if (isSet(target))
          return new Set(target);
      return target;
  };
  /**
   * Get the value from an object. This is for end-user objects. E.g. not
   * accessing a symbol property on a Map object.
   */
  const getValue = (target, prop) => {
      if (isMap(target))
          return target.get(prop);
      if (isSet(target))
          return prop;
      if (isArray(target))
          return target[prop];
      return target[prop];
  };
  const setValue = (mutableTarget, prop, value) => {
      if (isObject(mutableTarget)) {
          mutableTarget[prop] = value;
      }
      else if (isArray(mutableTarget)) {
          // @ts-ignore - is fine, prop can be a symbol
          mutableTarget[prop] = value;
      }
      else if (isMap(mutableTarget)) {
          // @ts-ignore
          mutableTarget.set(prop, value);
      }
      else if (isSet(mutableTarget)) {
          // @ts-ignore
          mutableTarget.add(value);
      }
      else {
          throw Error('Unexpected type');
      }
  };
  const getSize = (item) => {
      if (isObject(item))
          return Object.keys(item).length;
      // @ts-ignore - TS thinks item is never
      if (isArray(item))
          return item.length;
      // @ts-ignore - TS thinks item is never
      if (isMap(item) || isSet(item))
          return item.size;
      throw Error('Unexpected type');
  };
  /**
   * Shallow replaces the contents of one object with the contents of another.
   * The top level object will remain the same, but all changed content will
   * be replaced with the new content.
   */
  const replaceObject = (mutableTarget, nextObject) => {
      if (nextObject) {
          // From the new data, add to the old data anything that's new
          // (from the top level props only)
          Object.entries(nextObject).forEach(([prop, value]) => {
              if (mutableTarget[prop] !== value) {
                  mutableTarget[prop] = value;
              }
          });
          // Clear out any keys that aren't in the new data
          Object.keys(mutableTarget).forEach((prop) => {
              if (!(prop in nextObject)) {
                  delete mutableTarget[prop];
              }
          });
      }
      else {
          // Just empty the old object
          Object.keys(mutableTarget).forEach((prop) => {
              delete mutableTarget[prop];
          });
      }
  };
  /**
   * Traverse a tree, calling a callback for each node with the item and the path.
   * This can either mutate each value, or return a new value to create a clone.
   * @example const clone = utils.updateDeep(original, utils.clone);
   * Only traverses the targets supported by Recollect.
   */
  const updateDeep = (mutableTarget, updater) => {
      const path = [];
      const processLevel = (target) => {
          const updated = updater(target, path.slice());
          // If the updater returns something, use it. Else mutate the original.
          const next = typeof updated !== 'undefined' ? updated : target;
          const handleEntry = (prop, value) => {
              path.push(prop);
              const processed = processLevel(value);
              path.pop();
              setValue(next, prop, processed);
          };
          if (isObject(next)) {
              Object.entries(next).forEach(([prop, value]) => {
                  handleEntry(prop, value);
              });
          }
          else if (isArray(next) || isMap(next)) {
              next.forEach((value, prop) => {
                  handleEntry(prop, value);
              });
          }
          else if (isSet(next)) {
              // A set is special - you can't reassign what's in a particular
              // 'position' like the other three, so we do some fancy footwork...
              const setContents = Array.from(next);
              next.clear();
              setContents.forEach((value) => {
                  handleEntry(value, value);
              });
          }
          return next;
      };
      return processLevel(mutableTarget);
  };
  /**
   * Does some work while the proxy is muted. Returns the result of the
   * callback as a convenience.
   * This prevents components from being subscribed to reads from the store,
   * it does not prevent updates being triggered.
   */
  const whileMuted = (cb) => {
      state.proxyIsMuted = true;
      const result = cb();
      state.proxyIsMuted = false;
      return result;
  };
  /**
   * This is a convenience method that triggers a read on each item in the array.
   * When used during the render cycle of a collected component, it has the
   * side-effect of subscribing that component to each item in the array.
   */
  const useProps = (props) => {
      // useProps must never return, so it can be used in the body of a component
      props.includes(0);
  };

  // Joins an array that potentially contains symbols, which need an explicit
  // 'toString()'
  const join = (arr, joiner) => arr.map((item) => item.toString()).join(joiner);
  /**
   * Convert a target and a prop into a user-friendly string like store.tasks.1.done
   */
  const makeUserString = (propPath) => join(propPath, '.');
  const makeInternalString = (propPath) => join(propPath, PROP_PATH_SEP);
  /**
   * Convert an internal string like `one~~~two~~~three` into a user-facing string
   * like `one.two.three`
   */
  const internalToUser = (internalPath) => makeUserString(internalPath.split(PROP_PATH_SEP));
  /**
   * Takes the path stored in an object, and a new prop, and returns the two
   * combined
   */
  const extend = (target, prop) => {
      const basePath = target[PATH] || [];
      if (typeof prop === 'undefined')
          return basePath;
      return basePath.concat(prop);
  };
  /**
   * Convert a target and a prop into a user-friendly string like store.tasks.1.done
   */
  const extendToUserString = (target, prop) => makeUserString(extend(target, prop));
  const addProp = (target, propPath) => {
      if (!target)
          return;
      Object.defineProperty(target, PATH, {
          value: propPath,
          writable: true,
      });
  };
  const get = (target) => target[PATH] || [];
  const has = (target) => isObject(target) && PATH in target;

  const hasLocalStorage = typeof window !== 'undefined' && !!window.localStorage;
  const set = (key, data) => {
      if (!hasLocalStorage)
          return undefined;
      try {
          const string = typeof data === 'string' ? data : JSON.stringify(data);
          return localStorage.setItem(key, string);
      }
      catch (err) {
          return undefined;
      }
  };
  const get$1 = (key) => {
      if (!hasLocalStorage)
          return undefined;
      const data = localStorage.getItem(key);
      if (!data)
          return data;
      try {
          return JSON.parse(data);
      }
      catch (err) {
          // So we return whatever we've got on a failure
          // E.g. the data could be a plain string, which errors on JSON.parse.
          return data;
      }
  };

  const DEBUG_ON = 'on';
  const DEBUG_OFF = 'off';
  let DEBUG = get$1(LS_KEYS.RR_DEBUG) || DEBUG_OFF;
  if (DEBUG === DEBUG_ON) {
      console.info('Recollect debugging is enabled. Type __RR__.debugOff() to turn it off.');
  }
  const debugOn = () => {
      DEBUG = DEBUG_ON;
      set(LS_KEYS.RR_DEBUG, DEBUG_ON);
  };
  const debugOff = () => {
      DEBUG = DEBUG_OFF;
      set(LS_KEYS.RR_DEBUG, DEBUG_OFF);
  };
  const debug = (cb) => {
      if (DEBUG === DEBUG_ON)
          cb();
  };
  const logGet = (target, prop, value) => {
      debug(() => {
          console.groupCollapsed(`GET: ${extendToUserString(target, prop)}`);
          console.info(`Component: <${state.currentComponent._name}>`);
          if (typeof value !== 'undefined') {
              console.info('Value:', value);
          }
          console.groupEnd();
      });
  };
  const logSet = (target, prop, value) => {
      debug(() => {
          console.groupCollapsed(`SET: ${extendToUserString(target, prop)}`);
          console.info('From:', getValue(target, prop));
          console.info('To:  ', value);
          console.groupEnd();
      });
  };
  const logDelete = (target, prop) => {
      debug(() => {
          console.groupCollapsed(`DELETE: ${extendToUserString(target, prop)}`);
          console.info('Property: ', extendToUserString(target, prop));
          console.groupEnd();
      });
  };
  const logUpdate = (component, propsUpdated) => {
      debug(() => {
          console.groupCollapsed(`UPDATE:  <${component._name}>`);
          console.info('Changed properties:', propsUpdated);
          console.groupEnd();
      });
  };
  const getComponentsAndListeners = (componentFirst, matcher, makeName) => {
      const result = {};
      Array.from(state.listeners).forEach(([path, componentSet]) => {
          componentSet.forEach((component) => {
              var _a;
              let componentName = component._name;
              if (makeName) {
                  componentName += (_a = makeName(component.props)) !== null && _a !== void 0 ? _a : '';
              }
              const userPath = internalToUser(path);
              const prop = componentFirst ? componentName : userPath;
              const value = componentFirst ? userPath : componentName;
              if (matcher && !prop.match(matcher))
                  return;
              if (!result[prop])
                  result[prop] = [];
              if (!result[prop].includes(value))
                  result[prop].push(value);
          });
      });
      return result;
  };
  /**
   * Return an object where the keys are component names and the values are
   * arrays of the store properties the component is subscribed to
   */
  const getListenersByComponent = (matcher, makeName) => getComponentsAndListeners(true, matcher, makeName);
  /**
   * Return an object where the keys are store properties and the values are
   * the names of the components that listen to the property
   */
  const getComponentsByListener = (matcher, makeName) => getComponentsAndListeners(false, matcher, makeName);

  const subscribers = {};
  const onUpdateInNextStore = (func) => {
      subscribers["UpdateNextStore" /* UpdateNextStore */] = func;
  };
  const dispatchUpdateInNextStore = (data) => {
      return subscribers["UpdateNextStore" /* UpdateNextStore */](data);
  };
  /**
   * Add a callback to be called every time the store changes
   */
  const afterChange = (cb) => {
      state.manualListeners.push(cb);
  };

  /**
   * Add a new listener to be notified when a particular value in the store changes
   * To be used when a component reads from a property.
   */
  const addListener = (propPath) => {
      if (!state.currentComponent)
          return;
      // We use a string instead of an array because it's much easier to match
      const pathString = makeInternalString(propPath);
      const components = state.listeners.get(pathString) || new Set();
      components.add(state.currentComponent);
      state.listeners.set(pathString, components);
  };
  /**
   * These are the proxy handlers. Notes:
   * * We have different handlers (different traps) for object/array and
   *    map/set.
   * * When the proxy is muted, use Reflect[trap] and bypass any logic. The
   *    exception is Map/Set methods, where we must bind `this` first
   * * `ORIGINAL` lets us unwrap a proxied object
   * * We redirect to the 'next version' of a target if it has been changed
   */
  const getHandlerForObject = (targetObject) => {
      if (isMap(targetObject) || isSet(targetObject)) {
          // Map() and Set() get a special handler, because reads and writes all
          // happen in the get() trap (different to the get() method of the map/set!)
          return {
              get(target, prop) {
                  if (prop === ORIGINAL)
                      return target;
                  let result = Reflect.get(target, prop);
                  // The innards of Map and Set require this binding
                  if (isFunction(result))
                      result = result.bind(target);
                  // Bail early for some things. Unlike objects/arrays, we will
                  // continue on even if !state.currentComponent
                  if (state.proxyIsMuted || isInternal(prop)) {
                      return result;
                  }
                  if (!state.currentComponent && state.redirectToNext) {
                      const nextVersion = state.nextVersionMap.get(target);
                      if (nextVersion)
                          return Reflect.get(nextVersion, prop);
                  }
                  // Adding to a Map
                  if (prop === "set" /* Set */) {
                      const handler = {
                          apply(func, applyTarget, [key, value]) {
                              if (applyTarget.get(key) === value)
                                  return true; // No change, no need to carry on
                              return dispatchUpdateInNextStore({
                                  target: applyTarget,
                                  prop: key,
                                  value,
                                  updater: (finalTarget, newProxiedValue) => {
                                      logSet(target, prop, newProxiedValue);
                                      // We call the map.set() now, but on the item in the
                                      // store, and with the new args
                                      return Reflect.apply(finalTarget[prop], finalTarget, [
                                          key,
                                          newProxiedValue,
                                      ]);
                                  },
                              });
                          },
                      };
                      return new Proxy(result, handler);
                  }
                  // Adding to a Set
                  if (prop === "add" /* Add */) {
                      const handler = {
                          apply(func, applyTarget, [value]) {
                              if (applyTarget.has(value))
                                  return true; // Would be a no op
                              return dispatchUpdateInNextStore({
                                  target: applyTarget,
                                  notifyTarget: true,
                                  value,
                                  updater: (finalTarget, newProxiedValue) => {
                                      logSet(target, prop, newProxiedValue);
                                      return Reflect.apply(finalTarget[prop], finalTarget, [
                                          newProxiedValue,
                                      ]);
                                  },
                              });
                          },
                      };
                      return new Proxy(result, handler);
                  }
                  // On either a Set or Map
                  if (prop === "clear" /* Clear */ || prop === "delete" /* Delete */) {
                      const handler = {
                          apply(func, applyTarget, [key]) {
                              if (!applyTarget.size ||
                                  (prop === "delete" /* Delete */ && !applyTarget.has(key))) {
                                  return false; // false indicates no change
                              }
                              return dispatchUpdateInNextStore({
                                  target: applyTarget,
                                  notifyTarget: true,
                                  updater: (finalTarget) => {
                                      logSet(target, prop);
                                      return Reflect.apply(finalTarget[prop], finalTarget, [key]);
                                  },
                              });
                          },
                      };
                      return new Proxy(result, handler);
                  }
                  // Now that we've handled any modifying methods, we can
                  // just return the result if we're not in the render cycle.
                  if (!state.currentComponent)
                      return result;
                  // If we're reading a particular value, we'll want a listener for that
                  // We don't listen on `.has` because any change that would result in
                  // `.has` returning a different value would update the target
                  if (isMap(target) && prop === "get" /* Get */) {
                      const handler = {
                          apply(func, applyTarget, args) {
                              addListener(extend(target, args[0]));
                              return Reflect.apply(func, applyTarget, args);
                          },
                      };
                      return new Proxy(result, handler);
                  }
                  // For all other read operations, just return
                  return result;
              },
          };
      }
      return {
          get(target, prop) {
              // This allows getting the un-proxied version of a proxied object
              if (prop === ORIGINAL)
                  return target;
              const result = Reflect.get(target, prop);
              if (state.proxyIsMuted || isInternal(prop))
                  return result;
              // Mutating array methods make a lot of noise, so we wrap them in a proxy
              // Only one update will be fired - for the actual array.
              if (isArrayMutation(target, prop)) {
                  const handler = {
                      apply(func, applyTarget, args) {
                          return dispatchUpdateInNextStore({
                              target: applyTarget,
                              notifyTarget: true,
                              value: args,
                              updater: (finalTarget, proxiedArgs) => {
                                  logSet(target, prop, proxiedArgs);
                                  const updateResult = Reflect.apply(
                                  // @ts-ignore - Yes, symbol CAN be used as an index type
                                  finalTarget[prop], finalTarget, proxiedArgs);
                                  const rootPath = get(target);
                                  // At this point, the array is updated. But the paths of the
                                  // items could be wrong, so we refresh them.
                                  updateDeep(finalTarget, (item, path) => {
                                      if (isTarget(item)) {
                                          addProp(item, [...rootPath, ...path]);
                                      }
                                  });
                                  return updateResult;
                              },
                          });
                      },
                  };
                  return new Proxy(result, handler);
              }
              // For all other methods (.join, .toString(), etc) return the function
              // @ts-ignore - wrong, symbol can be used an an index type
              if (isFunction(target[prop]))
                  return result;
              if (state.currentComponent) {
                  // We record a get if a component is rendering, with the exception
                  // of reading array length. This would be redundant, since changes to
                  // length trigger a change on the array itself
                  if (!(isArray(target) && prop === "length" /* Length */)) {
                      logGet(target, prop, result);
                      addListener(extend(target, prop));
                  }
              }
              else if (state.redirectToNext) {
                  // When we're outside the render cycle, we route
                  // requests to the 'next version'
                  // Note, this will result in another get(), but on the equivalent
                  // target from the next store. muteProxy will be set so this line
                  // isn't triggered in an infinite loop
                  const nextVersion = state.nextVersionMap.get(target);
                  if (nextVersion)
                      return Reflect.get(nextVersion, prop);
              }
              return result;
          },
          has(target, prop) {
              const result = Reflect.has(target, prop);
              if (state.proxyIsMuted || isInternal(prop))
                  return result;
              if (state.currentComponent) {
                  // Arrays use `has` too, but we capture a listener elsewhere for that.
                  // Here we only want to capture access to objects
                  if (!isArray(target)) {
                      logGet(target, prop);
                      addListener(extend(target, prop));
                  }
              }
              else {
                  const nextVersion = state.nextVersionMap.get(target);
                  if (nextVersion)
                      return Reflect.has(nextVersion, prop);
              }
              return result;
          },
          ownKeys(target) {
              const result = Reflect.ownKeys(target);
              if (state.proxyIsMuted)
                  return result;
              if (state.currentComponent) {
                  logGet(target);
                  addListener(get(target));
              }
              else {
                  const nextVersion = state.nextVersionMap.get(target);
                  if (nextVersion)
                      return Reflect.ownKeys(nextVersion);
              }
              return result;
          },
          set(target, prop, value) {
              if (state.proxyIsMuted)
                  return Reflect.set(target, prop, value);
              {
                  if (state.currentComponent) {
                      console.error([
                          `You are attempting to modify the store during a render cycle. `,
                          `(You're setting "${prop.toString()}" to "${value}" somewhere)\n`,
                          `This could result in subtle bugs. `,
                          `If you're changing the store in componentDidMount, wrap your `,
                          `code in a setTimeout() to allow the render cycle to complete `,
                          `before changing the store.`,
                      ].join(''));
                  }
              }
              // If there's no change, we return
              // @ts-ignore - target[prop] is fine
              if (target[prop] === value)
                  return true;
              return dispatchUpdateInNextStore({
                  target,
                  prop,
                  value,
                  updater: (finalTarget, newValueProxy) => {
                      logSet(target, prop, newValueProxy);
                      return Reflect.set(finalTarget, prop, newValueProxy);
                  },
              });
          },
          deleteProperty(target, prop) {
              if (state.proxyIsMuted)
                  return Reflect.deleteProperty(target, prop);
              return dispatchUpdateInNextStore({
                  target,
                  prop,
                  notifyTarget: true,
                  updater: (finalTarget) => {
                      logDelete(target, prop);
                      return Reflect.deleteProperty(finalTarget, prop);
                  },
              });
          },
      };
  };
  /**
   * Wrap an item in a proxy
   */
  const createShallow = (target) => {
      {
          if (!target)
              throw Error('There is no target');
      }
      return new Proxy(target, getHandlerForObject(target));
  };

  /* eslint-disable import/no-unresolved */
  // unstable_batchedUpdates could be removed in a future major version
  // So we'll provide a fallback
  // https://github.com/facebook/react/issues/18602
  var batchedUpdates = ReactDOM.unstable_batchedUpdates ||
      ((cb) => {
          cb();
      });

  const queue = {
      components: new Map(),
      changedPaths: new Set(),
  };
  const flushUpdates = () => {
      // We batch updates here so that React will collect all setState() calls
      // (one for each component being updated) before triggering a render.
      // In other words: MANY .update() calls, ONE render.
      // This is subtly different to what the Recollect batch() function does -
      // it ensures that the listeners are only notified once for
      // multiple store changes
      // In other words: MANY store updates, ONE call to flushUpdates()
      batchedUpdates(() => {
          queue.components.forEach((propsUpdated, component) => {
              logUpdate(component, Array.from(propsUpdated));
              component.update();
          });
      });
      state.manualListeners.forEach((cb) => cb({
          changedProps: Array.from(queue.changedPaths),
          renderedComponents: Array.from(queue.components.keys()),
          store: state.store,
      }));
      queue.components.clear();
      queue.changedPaths.clear();
  };
  /**
   * Updates any component listening to:
   * - the exact propPath that has been changed. E.g. `tasks.2`
   * - a path further up the object tree. E.g. a component listening
   *   on `tasks.0` need to know if `tasks = 'foo'` happens
   * And if the path being notified is the top level (an empty path), everyone
   * gets updated.
   */
  const notifyByPath = (propPath) => {
      const pathString = makeInternalString(propPath);
      const userFriendlyPropPath = makeUserString(propPath);
      queue.changedPaths.add(userFriendlyPropPath);
      state.listeners.forEach((components, listenerPath) => {
          if (pathString === '' || // Notify everyone for top-level changes
              pathString === listenerPath) {
              components.forEach((component) => {
                  const propsUpdated = queue.components.get(component) || new Set();
                  propsUpdated.add(userFriendlyPropPath);
                  queue.components.set(component, propsUpdated);
              });
          }
      });
      // If we're not batch updating, flush the changes now, otherwise this
      // will be called when the batch is complete
      if (!state.isBatchUpdating)
          flushUpdates();
  };
  const removeListenersForComponent = (componentToRemove) => {
      state.listeners.forEach((components, listenerPath) => {
          const filteredComponents = Array.from(components).filter((existingComponent) => existingComponent !== componentToRemove);
          if (filteredComponents.length) {
              state.listeners.set(listenerPath, new Set(filteredComponents));
          }
          else {
              // If there are no components left listening, remove the path
              // For example, leaving a page will unmount a bunch of components
              state.listeners.delete(listenerPath);
          }
      });
  };

  /**
   * This is the store, as exported to the user. When the store is passed to a
   * component, it is shallow cloned. This leaves us free to mutate the root
   * level directly.
   */
  state.store = createShallow({});
  /**
   * Deep update the store, the following rules are followed:
   * - If updating the root level, the store object itself is mutated.
   * - For any other (deep) update we clone each node along the path to
   *   the target to update (the target is cloned too).
   */
  const updateStore = ({ target, prop, value, notifyTarget = false, updater, }) => whileMuted(() => {
      let result;
      // This function doesn't know anything about the prop being set.
      // It just finds the target (the parent of the prop) and
      // calls updater() with it.
      const targetPath = get(target);
      // Note that if this update is a method (e.g. arr.push()) then prop can be
      // undefined, meaning the prop path won't be extended, and will just be
      // the path of the target (the array) which is correct.
      const propPath = extend(target, prop);
      // If we change the length/size of an array/map/set, we will want to
      // trigger a render of the parent path.
      let targetChangedSize = false;
      const initialSize = getSize(target);
      let newValue = value;
      // Make sure the new value is deeply wrapped in proxies, if it's a target
      if (isTarget(newValue)) {
          newValue = updateDeep(value, (item, thisPropPath) => {
              if (!isTarget(item))
                  return item;
              const next = clone(item);
              addProp(next, [...propPath, ...thisPropPath]);
              return createShallow(next);
          });
      }
      if (!targetPath.length) {
          // If the target is the store root, it's mutated in place.
          result = updater(state.store, newValue);
          targetChangedSize = getSize(state.store) !== initialSize;
      }
      else {
          targetPath.reduce((item, thisProp, i) => {
              const thisValue = getValue(item, thisProp);
              // Shallow clone this level
              let clone$1 = clone(thisValue);
              addProp(clone$1, get(thisValue));
              // Wrap the clone in a proxy
              clone$1 = createShallow(clone$1);
              // Mutate this level (swap out the original for the clone)
              setValue(item, thisProp, clone$1);
              // If we're at the end of the path, then 'clone' is our target
              if (i === targetPath.length - 1) {
                  result = updater(clone$1, newValue);
                  targetChangedSize = getSize(clone$1) !== initialSize;
                  // We keep a reference between the original target and the clone
                  // `target` may or may not be wrapped in a proxy (Maps and Sets are)
                  // So we check/get the unproxied version
                  state.nextVersionMap.set(target[ORIGINAL] || target, clone$1);
              }
              return clone$1;
          }, state.store);
      }
      // If the 'size' of a target changes, it's reasonable to assume that
      // users of the target are going to need to re-render, else use the prop
      const notifyPath = notifyTarget || targetChangedSize ? targetPath : propPath;
      notifyByPath(notifyPath);
      return result;
  });
  onUpdateInNextStore(updateStore);
  /**
   * Executes the provided function, then updates appropriate components and calls
   * listeners registered with `afterChange()`. Guaranteed to only trigger one
   * update. The provided function must only contain synchronous code.
   */
  const batch = (cb) => {
      state.isBatchUpdating = true;
      cb();
      state.isBatchUpdating = false;
      flushUpdates();
  };
  /**
   * Empty the Recollect store and replace it with new data.
   */
  const initStore = (data) => {
      batch(() => {
          replaceObject(state.store, data);
      });
  };

  const timeTravelState = {
      currentIndex: 0,
      history: [],
      historyLimit: 50,
      muteHistory: false,
  };
  const pruneHistory = () => {
      if (timeTravelState.history.length > timeTravelState.historyLimit) {
          const removeCount = timeTravelState.history.length - timeTravelState.historyLimit;
          timeTravelState.history.splice(0, removeCount);
          timeTravelState.currentIndex = timeTravelState.history.length - 1;
      }
  };
  /**
   * Pick the store instance at the defined index from history
   * and apply it as the current store
   */
  const applyStoreAtIndex = () => {
      const nextStore = timeTravelState.history[timeTravelState.currentIndex].store;
      timeTravelState.muteHistory = true;
      initStore(nextStore);
      timeTravelState.muteHistory = false;
      console.info(`Showing index ${timeTravelState.currentIndex} of ${timeTravelState.history.length - 1}`);
  };
  /**
   * Apply a limit to the number of history items to keep in memory
   */
  const setHistoryLimit = (num) => {
      if (typeof num === 'number') {
          set(LS_KEYS.RR_HISTORY_LIMIT, num);
          timeTravelState.historyLimit = num;
          pruneHistory();
          if (num === 0) {
              console.info('Time travel is now turned off');
          }
      }
      else {
          console.error(num, 'must be a number');
      }
  };
  /**
   * Return this history array.
   * We return the data without the proxies for readability. We do this when
   * retrieving rather than when putting the store in history for performance.
   */
  const getHistory = () => {
      state.redirectToNext = false;
      const cleanStore = updateDeep(timeTravelState.history, (item) => clone(item));
      state.redirectToNext = true;
      return cleanStore;
  };
  const back = () => {
      if (!timeTravelState.currentIndex) {
          console.info('You are already at the beginning');
      }
      else {
          timeTravelState.currentIndex--;
          applyStoreAtIndex();
      }
  };
  const forward = () => {
      if (timeTravelState.currentIndex === timeTravelState.history.length - 1) {
          console.info('You are already at the end');
      }
      else {
          timeTravelState.currentIndex++;
          applyStoreAtIndex();
      }
  };
  const goTo = (index) => {
      if (typeof index !== 'number' ||
          index > timeTravelState.history.length - 1 ||
          index < 0) {
          console.warn(`${index} is not valid. Pick a number between 0 and ${timeTravelState.history.length - 1}.`);
      }
      else {
          timeTravelState.currentIndex = index;
          applyStoreAtIndex();
      }
  };
  /**
   * For resetting history between tests
   */
  const clearHistory = () => {
      timeTravelState.history.length = 0;
      timeTravelState.currentIndex = 0;
  };
  // We wrap this in a NODE_ENV check so rollup ignores it during build
  // (it doesn't work this out from the NODE_ENV check in index.ts)
  {
      const storedHistoryLimit = get$1(LS_KEYS.RR_HISTORY_LIMIT);
      if (storedHistoryLimit && typeof storedHistoryLimit === 'number') {
          timeTravelState.historyLimit = storedHistoryLimit;
      }
      let pruneQueueTimeout; // NodeJs.Timer or number
      timeTravelState.history.push({
          store: Object.assign({}, state.store),
          changedProps: ['INITIAL_STATE'],
      });
      afterChange((e) => {
          // Setting historyLimit to 0 turns off time travel
          if (!timeTravelState.muteHistory && timeTravelState.historyLimit !== 0) {
              // If we're not looking at the most recent point in history, discard
              // everything in the future
              if (timeTravelState.history.length && // False the very first time this fires
                  timeTravelState.currentIndex !== timeTravelState.history.length - 1) {
                  timeTravelState.history.length = timeTravelState.currentIndex + 1;
              }
              // We shallow clone because the store OBJECT gets mutated
              // Don't need to deep clone since the store CONTENTS never mutate
              timeTravelState.history.push({
                  store: Object.assign({}, e.store),
                  changedProps: e.changedProps,
              });
              timeTravelState.currentIndex = timeTravelState.history.length - 1;
              clearTimeout(pruneQueueTimeout);
              pruneQueueTimeout = setTimeout(pruneHistory, 100);
          }
      });
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var reactIs_development = createCommonjsModule(function (module, exports) {



  {
    (function() {

  // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.
  var hasSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
  var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
  var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
  var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
  var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
  var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
  var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
  // (unstable) APIs that have been removed. Can we remove the symbols?

  var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
  var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
  var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
  var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
  var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
  var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
  var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
  var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
  var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
  var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
  var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

  function isValidElementType(type) {
    return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
    type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
  }

  function typeOf(object) {
    if (typeof object === 'object' && object !== null) {
      var $$typeof = object.$$typeof;

      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          var type = object.type;

          switch (type) {
            case REACT_ASYNC_MODE_TYPE:
            case REACT_CONCURRENT_MODE_TYPE:
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
              return type;

            default:
              var $$typeofType = type && type.$$typeof;

              switch ($$typeofType) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                case REACT_PROVIDER_TYPE:
                  return $$typeofType;

                default:
                  return $$typeof;
              }

          }

        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }

    return undefined;
  } // AsyncMode is deprecated along with isAsyncMode

  var AsyncMode = REACT_ASYNC_MODE_TYPE;
  var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
  var ContextConsumer = REACT_CONTEXT_TYPE;
  var ContextProvider = REACT_PROVIDER_TYPE;
  var Element = REACT_ELEMENT_TYPE;
  var ForwardRef = REACT_FORWARD_REF_TYPE;
  var Fragment = REACT_FRAGMENT_TYPE;
  var Lazy = REACT_LAZY_TYPE;
  var Memo = REACT_MEMO_TYPE;
  var Portal = REACT_PORTAL_TYPE;
  var Profiler = REACT_PROFILER_TYPE;
  var StrictMode = REACT_STRICT_MODE_TYPE;
  var Suspense = REACT_SUSPENSE_TYPE;
  var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

  function isAsyncMode(object) {
    {
      if (!hasWarnedAboutDeprecatedIsAsyncMode) {
        hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

        console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
      }
    }

    return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
  }
  function isConcurrentMode(object) {
    return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
  }
  function isContextConsumer(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  }
  function isContextProvider(object) {
    return typeOf(object) === REACT_PROVIDER_TYPE;
  }
  function isElement(object) {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function isForwardRef(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  }
  function isFragment(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  }
  function isLazy(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  }
  function isMemo(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  }
  function isPortal(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  }
  function isProfiler(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  }
  function isStrictMode(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  }
  function isSuspense(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  }

  exports.AsyncMode = AsyncMode;
  exports.ConcurrentMode = ConcurrentMode;
  exports.ContextConsumer = ContextConsumer;
  exports.ContextProvider = ContextProvider;
  exports.Element = Element;
  exports.ForwardRef = ForwardRef;
  exports.Fragment = Fragment;
  exports.Lazy = Lazy;
  exports.Memo = Memo;
  exports.Portal = Portal;
  exports.Profiler = Profiler;
  exports.StrictMode = StrictMode;
  exports.Suspense = Suspense;
  exports.isAsyncMode = isAsyncMode;
  exports.isConcurrentMode = isConcurrentMode;
  exports.isContextConsumer = isContextConsumer;
  exports.isContextProvider = isContextProvider;
  exports.isElement = isElement;
  exports.isForwardRef = isForwardRef;
  exports.isFragment = isFragment;
  exports.isLazy = isLazy;
  exports.isMemo = isMemo;
  exports.isPortal = isPortal;
  exports.isProfiler = isProfiler;
  exports.isStrictMode = isStrictMode;
  exports.isSuspense = isSuspense;
  exports.isValidElementType = isValidElementType;
  exports.typeOf = typeOf;
    })();
  }
  });
  var reactIs_development_1 = reactIs_development.AsyncMode;
  var reactIs_development_2 = reactIs_development.ConcurrentMode;
  var reactIs_development_3 = reactIs_development.ContextConsumer;
  var reactIs_development_4 = reactIs_development.ContextProvider;
  var reactIs_development_5 = reactIs_development.Element;
  var reactIs_development_6 = reactIs_development.ForwardRef;
  var reactIs_development_7 = reactIs_development.Fragment;
  var reactIs_development_8 = reactIs_development.Lazy;
  var reactIs_development_9 = reactIs_development.Memo;
  var reactIs_development_10 = reactIs_development.Portal;
  var reactIs_development_11 = reactIs_development.Profiler;
  var reactIs_development_12 = reactIs_development.StrictMode;
  var reactIs_development_13 = reactIs_development.Suspense;
  var reactIs_development_14 = reactIs_development.isAsyncMode;
  var reactIs_development_15 = reactIs_development.isConcurrentMode;
  var reactIs_development_16 = reactIs_development.isContextConsumer;
  var reactIs_development_17 = reactIs_development.isContextProvider;
  var reactIs_development_18 = reactIs_development.isElement;
  var reactIs_development_19 = reactIs_development.isForwardRef;
  var reactIs_development_20 = reactIs_development.isFragment;
  var reactIs_development_21 = reactIs_development.isLazy;
  var reactIs_development_22 = reactIs_development.isMemo;
  var reactIs_development_23 = reactIs_development.isPortal;
  var reactIs_development_24 = reactIs_development.isProfiler;
  var reactIs_development_25 = reactIs_development.isStrictMode;
  var reactIs_development_26 = reactIs_development.isSuspense;
  var reactIs_development_27 = reactIs_development.isValidElementType;
  var reactIs_development_28 = reactIs_development.typeOf;

  var reactIs = createCommonjsModule(function (module) {

  {
    module.exports = reactIs_development;
  }
  });

  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

  function getStatics(component) {
    // React v16.11 and below
    if (reactIs.isMemo(component)) {
      return MEMO_STATICS;
    } // React v16.12 and above


    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
  }

  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
      // don't hoist over string (html) components
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);

        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }

      var keys = getOwnPropertyNames(sourceComponent);

      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }

      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);

      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];

        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

          try {
            // Avoid failures from read-only properties
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {}
        }
      }
    }

    return targetComponent;
  }

  var hoistNonReactStatics_cjs = hoistNonReactStatics;

  // As we render down into a tree of collected components, we will start/stop
  // recording
  const componentStack = [];
  const startRecordingGetsForComponent = (component) => {
      if (!state.isInBrowser)
          return;
      debug(() => {
          console.groupCollapsed(`RENDER: <${component._name}>`);
      });
      state.currentComponent = component;
      componentStack.push(state.currentComponent);
  };
  const stopRecordingGetsForComponent = () => {
      if (!state.isInBrowser)
          return;
      debug(() => {
          console.groupEnd();
      });
      componentStack.pop();
      state.currentComponent = componentStack[componentStack.length - 1] || null;
  };
  /**
   * This shallow clones the store to pass as state to the collected
   * component.
   */
  const getStoreClone = () => whileMuted(() => {
      // We'll shallow clone the store so React knows it's new
      const shallowClone = Object.assign({}, state.store);
      // ... but redirect all reads to the real store
      state.nextVersionMap.set(shallowClone, state.store);
      return createShallow(shallowClone);
  });
  const collect = (ComponentToWrap) => {
      const componentName = ComponentToWrap.displayName || ComponentToWrap.name || 'NamelessComponent';
      class WrappedComponent extends React.PureComponent {
          constructor() {
              super(...arguments);
              this.state = {
                  // This might be called by React when a parent component has updated with a new store,
                  // we want this component (if it's a child) to have that next store as well.
                  store: getStoreClone(),
              };
              // TODO (davidg) 2020-02-28: use private #isMounted, waiting on
              //  https://github.com/prettier/prettier/issues/7263
              this._isMounted = false;
              this._isMounting = true;
              // <React.StrictMode> will trigger multiple renders,
              // we must disregard these
              this._isRendering = false;
              this._name = componentName;
          }
          componentDidMount() {
              this._isMounted = true;
              this._isMounting = false;
              // A user shouldn't pass data from the store into a collected component.
              // See the issue linked in the error for details.
              {
                  if (this.props) {
                      const recollectStoreProps = [];
                      // Note this is only a shallow check.
                      Object.entries(this.props).forEach(([propName, propValue]) => {
                          // If this prop has a 'path', we know it's from the Recollect store
                          // This is not good!
                          if (has(propValue))
                              recollectStoreProps.push(propName);
                      });
                      // We'll just report the first match to keep the message simple
                      if (recollectStoreProps.length) {
                          console.error(`You are passing part of the Recollect store from one collected component to another, which can cause unpredictable behaviour.\n Either remove the collect() wrapper from <${this._name}/>, or remove the "${recollectStoreProps[0]}" prop.\n More info: https://git.io/JvMOj`);
                      }
                  }
              }
              // Stop recording. For first render()
              stopRecordingGetsForComponent();
              this._isRendering = false;
          }
          componentDidUpdate() {
              // Stop recording. For not-first render()
              stopRecordingGetsForComponent();
              this._isRendering = false;
          }
          componentWillUnmount() {
              removeListenersForComponent(this);
              this._isMounted = false;
          }
          update() {
              // 1. If the component has already unmounted, don't try and set the state
              // 2. The component might not have mounted YET, but is in the middle of its first
              //    render cycle.
              //    For example, if a user sets store.loading to true in App.componentDidMount
              if (this._isMounted || this._isMounting) {
                  this.setState({ store: getStoreClone() });
              }
          }
          render() {
              if (!this._isRendering) {
                  startRecordingGetsForComponent(this);
                  this._isRendering = true;
              }
              const props = Object.assign(Object.assign({}, this.props), { store: this.state.store });
              return React.createElement(ComponentToWrap, Object.assign({}, props));
          }
      }
      WrappedComponent.displayName = `Collected(${componentName})`;
      // @ts-ignore - I can't work this out
      return hoistNonReactStatics_cjs(WrappedComponent, ComponentToWrap);
  };

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}

  	return Object(val);
  }

  function shouldUseNative() {
  	try {
  		if (!Object.assign) {
  			return false;
  		}

  		// Detect buggy property enumeration order in older V8 versions.

  		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
  		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
  		test1[5] = 'de';
  		if (Object.getOwnPropertyNames(test1)[0] === '5') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test2 = {};
  		for (var i = 0; i < 10; i++) {
  			test2['_' + String.fromCharCode(i)] = i;
  		}
  		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
  			return test2[n];
  		});
  		if (order2.join('') !== '0123456789') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test3 = {};
  		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
  			test3[letter] = letter;
  		});
  		if (Object.keys(Object.assign({}, test3)).join('') !==
  				'abcdefghijklmnopqrst') {
  			return false;
  		}

  		return true;
  	} catch (err) {
  		// We don't expect any of the above to throw, but better to be safe.
  		return false;
  	}
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;

  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);

  		for (var key in from) {
  			if (hasOwnProperty.call(from, key)) {
  				to[key] = from[key];
  			}
  		}

  		if (getOwnPropertySymbols$1) {
  			symbols = getOwnPropertySymbols$1(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}

  	return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  var printWarning = function() {};

  {
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};
    var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

    printWarning = function(text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */
  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    {
      for (var typeSpecName in typeSpecs) {
        if (has$1(typeSpecs, typeSpecName)) {
          var error;
          // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.
          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error(
                (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
                'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
              );
              err.name = 'Invariant Violation';
              throw err;
            }
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning(
              (componentName || 'React class') + ': type specification of ' +
              location + ' `' + typeSpecName + '` is invalid; the type checker ' +
              'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
              'You may have forgotten to pass an argument to the type checker ' +
              'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
              'shape all require an argument).'
            );
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;

            var stack = getStack ? getStack() : '';

            printWarning(
              'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
            );
          }
        }
      }
    }
  }

  /**
   * Resets warning cache when testing.
   *
   * @private
   */
  checkPropTypes.resetWarningCache = function() {
    {
      loggedTypeFailures = {};
    }
  };

  var checkPropTypes_1 = checkPropTypes;

  var has$2 = Function.call.bind(Object.prototype.hasOwnProperty);
  var printWarning$1 = function() {};

  {
    printWarning$1 = function(text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */

    var ANONYMOUS = '<<anonymous>>';

    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),

      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker,
    };

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    /*eslint-disable no-self-compare*/
    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */
    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret_1) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            var err = new Error(
              'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
              'Use `PropTypes.checkPropTypes()` to call them. ' +
              'Read more at http://fb.me/use-check-prop-types'
            );
            err.name = 'Invariant Violation';
            throw err;
          } else if ( typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;
            if (
              !manualPropTypeCallCache[cacheKey] &&
              // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3
            ) {
              printWarning$1(
                'You are manually calling a React.PropTypes validation ' +
                'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
                'and will throw in the standalone `prop-types` package. ' +
                'You may be seeing this warning due to a third-party PropTypes ' +
                'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);

      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);

          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!reactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        {
          if (arguments.length > 1) {
            printWarning$1(
              'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
              'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
            );
          } else {
            printWarning$1('Invalid argument supplied to oneOf, expected an array.');
          }
        }
        return emptyFunctionThatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);
          if (type === 'symbol') {
            return String(value);
          }
          return value;
        });
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }
      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }
        for (var key in propValue) {
          if (has$2(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
         printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.') ;
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== 'function') {
          printWarning$1(
            'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
            'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
          );
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }
      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (!checker) {
            continue;
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        // We need to check all keys in case some are required but missing from
        // props.
        var allKeys = objectAssign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (!checker) {
            return new PropTypeError(
              'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
              '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
              '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
            );
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
          if (error) {
            return error;
          }
        }
        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;
        case 'boolean':
          return !propValue;
        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;
        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      }

      // falsy value can't be a Symbol
      if (!propValue) {
        return false;
      }

      // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      // Fallback for non-spec compliant Symbols which are polyfilled.
      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return 'array';
      }
      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }
      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }
      return propType;
    }

    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }
      return propType;
    }

    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;
        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;
        default:
          return type;
      }
    }

    // Returns class name of the object, if any.
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes_1;
    ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  var propTypes = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    var ReactIs = reactIs;

    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
  }
  });

  var OriginalPropTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': propTypes,
    __moduleExports: propTypes
  });

  let EnvPropTypes;
  // In the dev build of Recollect, we wrap PropTypes in a proxy so we can
  // mute the store while the prop types library reads the props.
  {
      // The PropTypes object is made up of functions that call functions, so
      // we recursively wrap responses in the same handler
      const wrapMeIfYouCan = (item, handler) => {
          if (typeof item === 'function' ||
              (typeof item === 'object' && item !== null)) {
              return new Proxy(item, handler);
          }
          return item;
      };
      const handler = {
          get(...args) {
              return wrapMeIfYouCan(Reflect.get(...args), this);
          },
          apply(...args) {
              // Here we mute the function calls
              const result = whileMuted(() => Reflect.apply(...args));
              return wrapMeIfYouCan(result, this);
          },
      };
      EnvPropTypes = new Proxy(OriginalPropTypes, handler);
  }
  // We do this so we're exporting a const (EnvPropTypes is a let)
  const PropTypes = EnvPropTypes;

  const { store } = state;
  // `internals` is not part of the Recollect API. It is used by tests.
  const internals = state;
  if (typeof window !== 'undefined') {
      if ('Proxy' in window) {
          window.__RR__ = {
              debugOn,
              debugOff,
              internals: state,
          };
          {
              // These two helpers will be included in the dev build only. A) for size, but
              // also B) in prod, component names tend to be obscured so they would be
              // of little use.
              window.__RR__.getListenersByComponent = getListenersByComponent;
              window.__RR__.getComponentsByListener = getComponentsByListener;
              // Time travel helpers have a performance/memory impact, so are only
              // included in the dev build
              window.__RR__.back = back;
              window.__RR__.forward = forward;
              window.__RR__.goTo = goTo;
              window.__RR__.getHistory = getHistory;
              window.__RR__.clearHistory = clearHistory;
              window.__RR__.setHistoryLimit = setHistoryLimit;
          }
      }
      else {
          console.warn("This browser doesn't support the Proxy object, which react-recollect needs. See https://caniuse.com/#search=proxy to find out which browsers do support it");
      }
  }

  exports.PropTypes = PropTypes;
  exports.afterChange = afterChange;
  exports.batch = batch;
  exports.collect = collect;
  exports.initStore = initStore;
  exports.internals = internals;
  exports.store = store;
  exports.useProps = useProps;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
